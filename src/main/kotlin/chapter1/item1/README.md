# 아이템 1 - 가변성을 제한하라

코틀린은 모듈로 프로그램을 설계합니다. 모듈은 `클래스`, `객체`, `함수`, `타입 별청(type alias)`, `톱 레벨(top-level) 프로퍼티` 등 다양한 요소로 구성됩니다.

이러한 요소 중 일부는 `상태(state)`를 가질 수 있습니다. 

예를 들어 읽고 쓸 수 있는 프로퍼티(read-write property) `var` 를 사용하거나, `mutable` 객체를 사용하면 상태를 가질 수 있습니다.

```kotlin
var a = 10
var list: MutableList<Int> = mutableListOf()
```
- 이처럼 요소가 상태를 갖는 경우, 해당 요소의 동작은 사용 방법뿐만 아니라 그 이력(history)에도 의존하게 됩니다.

### [BankAccount](./BankAccountSample.kt)
위 코드의 BankAccount 에는 계좌에 돈이 얼마나 있는지 나타내는 상태가 있습니다.
이처럼 상태를 갖게 하는 것은 양날의 검입니다.
시간의 변화에 따라서 변하는 요소를 표현할 수 있다는 것은 유용하지만, 상태를 적절하게 관리하는 것이 생각보다 꽤 어렵습니다.

1. 프로그램을 이해하고 디버그하기 힘들어집니다.
   - 상태를 갖는 부분들의 관계를 이해해야 하며, 상태 변경이 많아지면 이를 추적하는 것이 힘들어집니다.
   - 이러한 클래스는 이해하기도 어렵고, 이후에 코드를 수정하기도 힘듭니다.
   - 클래스가 예상하지 못한 상황 또는 오류를 발생시키는 경우에 큰 문제가 됩니다.
2. 가변성(mutability)이 있으면, 코드의 실행을 추론하기 어려워집니다.
   - 시점에 따라서 값이 달라질 수 있으므로, 현재 어떤 값을 갖고 있는지 알아야 코드의 실행을 예측할 수 있습니다.
   - 한 시점에 확인한 값이 계속 동일하게 유지된다고 확신할 수 없습니다.
3. 멀티스레드 프로그램일 때는 적절한 동기화가 필요합니다.
   - 변경이 일어나는 모든 부분에서 충돌이 발생할 수 있습니다.
4. 테스트하기 어렵습니다.
   - 모든 상태를 테스트해야 하므로, 변경이 많으면 많을수록 더 많은 조합을 테스트해야 합니다.
5. 상태 변경이 일어날 때, 이러한 변경을 다른 부분에 알려야 하는 경우가 있습니다.
   - 정렬되어 있는 리스트에 가변 요소를 추가한다면, 요소에 변경이 일어날 때마다 리스트 전체를 다시 정렬해야 합니다.

대규모 팀에서 일하고 있는 개발자라면 변경 가능한 부분에 의한 일관성(consistency)문제, 복잡성(complexity) 증가와 관련된 문제에 익숙할 것입니다.
공유 상태를 관리하는 것이 얼마나 힘든 일인지 간단한 예로 확인해 봅시다.

### [MultiThreadProperty](./MultiThreadProperty.kt)
- 위 코드는 멀티스레드를 활용해서 프로퍼티를 수정합니다.
- 충돌에 의해서 일부 연산이 이루어지지 않습니다.

### [MultiThreadPropertyCoroutine](./MultiThreadPropertyCoroutine.kt)
- 코틀린의 코루틴을 활용하면, 더 적은 스레드가 관여되므로 충돌과 관련된 문제가 줄어듭니다. 하지만 문제가 사리지는 것은 아닙니다.

일부 연산이 충돌되어 사라지므로 적절하게 추가로 동기화를 구현해야 합니다.
동기화를 잘 구현하는 것은 굉장히 어려운 일이고 변할 수 있는 지점이 많다면 훨씬 더 어려워집니다.
따라서 변할 수 이쓴ㄴ 지점은 줄일수록 좋습니다.

### [SynchronizationSample](./SynchronizationSample.kt)
- 가변은 생각보다 단점이 많아서 이를 완전하게 재한하는 프로그래밍 언어도 있습니다. 바로 순수 함수형 언어 입니다.
- 널리 알려진 순수 함수형 언어로는 하스켈(Haskell)이 있습니다. 이러한 프로그래밍 언어는 가변성에 너무 많은 제한이 걸려서 프로그램을 작성하기가 굉장히 어렵습니다.
- 가변성은 시스템의 상태를 나타내기 위한 중요한 방법이지만 변경이 일어나야 하는 부분을 신중하고 확실하게 결정하고 사용하기 바랍니다.

## 코틀린에서 가변성 제한하기

--- 

## 추가 궁금사항 정리

### @Throws 어노테이션

```kotlin
@Throws(InsufficientFunds::class)
```
- 이 어노테이션은 JVM 메소드로 컴파일될 때 함수에 의해 선언되어야 하는 예외를 나타냅니다.

변환 예:
```kotlin
// 선언
@Throws(IOException::class)
fun readFile(name: String): String {...}

-----------------------------------------------------

// 변환
String readFile(String name) throws IOException {...}
```